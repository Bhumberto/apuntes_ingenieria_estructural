import numpy as np
import matplotlib.pyplot as plt
import math
import columnas_utils as col
import pandas as pd
%cd ..\..\etabs_oapi
import sismo_utils as sis
import etabs_utils as etb
%cd ..\concreto\columnas


# Definicion de las unidades
N = 1
m = 1
cm = 1/100
Pa = 1
MPa = 10**6
pulg = 2.54 / 100

# Definicion de varillas de acero:
d_3 = 3/8 * pulg
d_4 = 1/2 * pulg
d_5 = 5/8 * pulg
d_6 = 3/4 * pulg
d_8 = 1 * pulg

A_3 = d_3 ** 2 /4 * math.pi
A_4 = d_4 ** 2 /4 * math.pi
A_5 = d_5 ** 2 /4 * math.pi
A_6 = d_6 ** 2 /4 * math.pi
A_8 = d_8 ** 2 /4 * math.pi

#Definiendo geometría de la columna
b = 35*cm
h = 75*cm
r = 4*cm
column = col.Column(b, h, r)

# Concreto
fc = 21*MPa #Resistencia a la compresion
eps_u = 0.003 #Deformación unitaria ultima
column.set_concrete(fc, eps_u)

#Acero de refuerzo
fy = 420*MPa #Esfuerzo a la fluencia del acero
Es = 200000*MPa #Módulo de elasticidad del acero
eps_y = fy/Es #Deformación de fluencia del acero
column.set_steel_reb(fy, Es)

#Acero de refuerzo colocado
d_p = d_5 #diámetro principal
d_s = d_5 #diámetro secundario
d_st = d_3 #diámetro del estribo
n_f = 6  #filas de acero
n_c = 3 #columnas de acero
column.set_rebar(d_p, d_s, d_st, n_f, n_c)

#factor de minoración
phi = 0.65
column.compress_resist(phi)

#Datos diagrama a flexocompresion
column.biaxial_flex_comp()

#Importación de cargas
cargas = pd.read_csv('cargas.csv',sep=';')

#Conversion de unidades
cargas.P = cargas.P*9.81*10**3
cargas.M2 = cargas.M2*9.81*10**3
cargas.M3 = cargas.M3*9.81*10**3

#Diagrama a flexocompresión
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
column.plot_bi_f_c(ax,loads=cargas)
plt.title('Diagrama de Flexocompresión')
ax.set_xlabel("$\phi Mn_x$ (kN-m)")
ax.set_ylabel("$\phi Mn_x$ (kN-m)")
ax.set_zlabel("$\phi Pn$ (kN)")
plt.show()

#Eje x
fig, ax = plt.subplots()
column.plot_f_c(ax,loads=cargas,axis='x')
plt.show()

#Eje y
fig, ax = plt.subplots()
column.plot_f_c(ax,loads=cargas,axis='y')
plt.show()

#Comprobacion Viga Debil Columna Fuerte
#Datos de la viga
viga_1 = col.Beam(b=25*cm,h=40*cm,r=9*cm)
viga_1.set_rebar(d_s=d_5, n_s=4)

#Momento Resistente máximo con acero en tracción solamente
phi_f = 0.9
viga_1.calc_Mnv(phi_f)

#Menor carga que no se encuentra en el ultimo nivel
P_min = cargas[cargas.Piso!=6]['P'].max()*-1

#Filtro de datos para la menor carga
data = column.biaxial_f_c
data = data[data.theta==0]
data = data[abs(data.Pn-P_min)== min(abs(data.Pn-P_min))]

#Momento de diseño
Mnx_des = float(data.Mn_x)

#Verificación:
if 2*Mnx_des > 1.2*(2*viga_1.Mn):
    print('OK')
else:
    print('Viga más fuerte que la columna')
    
#Verificación por longitud de desarrollo en la columna
lu = 1.95
lamb = 1
psi_g = 1
psi_e = 1
psi_s1 = 1
psi_s2 = 0.8
psi_ts = 1.3
psi_ti = 1
db = 0.75 * pulg

#restricciones de la norma:
psi_ts_e = psi_ts*psi_e 
if psi_ts_e > 1.7:
    psi_ts_e = 1.7
    
sqrt_fc = (fc/10**6)**0.5*MPa
if sqrt_fc > 8.3*MPa:
   sqrt_fc = 8.3*MPa
    
ld3 = fy/(1.1*lamb*sqrt_fc)*psi_g*psi_e*psi_s2*psi_g*db

#Verificación
if 1.25*ld3 <= lu/2:
    print('Ok')
else:
    print('El acero no puede desarrolarse en la columna')

#Considerando el efecto de los estribos:
r = geom['r']
d_st = steel['d_st']
nb = steel['n_c']

cb1 = r+d_st+db*0.5
cb2 = (b-2*r-2*d_st-db)/(nb-1)/2
cb = min(cb1,cb2)

k_tr = 0

#restricciones de la norma
alpha = (cb+k_tr)/db
if alpha > 2.5:
    alpha = 2.5

#Por tanto:
ld3 = ld3/alpha 

#Verificación
if 1.25*ld3 <= lu/2:
    print('Ok')
else:
    print('El acero no puede desarrolarse en la columna')


#Longitud de confinamiento
hn = 2.1*m
h = geom['h']
Lo = max(b,h,hn/6,45*cm)

#Confinamiento de barras:
P_max = cargas.P.min()


#Área de refuerzo transaversal
s = 10*cm
bc = b-2*r
hc = h-2*r
Ach = bc*hc

#Revisión X
Ash1 = 0.09*s*bc*fc/fy
Ash2 = 0.3*s*bc*(Ag/Ach-1)*fc/fy
Ash3 = 0
nl = 10
if 0.3*fc*Ag < P_max:
    print('Es necesario confinar todas las barras longitudinales')
    kf = fc/175+0.6
    if kf < 1.0:
        kf = 1.0 
    kn = nl/(nl-2)
    Ash3 = 0.2*kf*kn*P_max/(fy*Ach)
Ashx = max(Ash1,Ash2,Ash3)

#Revisión Y
Ash1 = 0.09*s*hc*fc/fy
Ash2 = 0.3*s*hc*(Ag/Ach-1)*fc/fy
Ash3 = 0
nl = 10
if 0.3*fc*Ag < P_max:
    print('Es necesario confinar todas las barras longitudinales')
    kf = fc/175+0.6
    if kf < 1.0:
        kf = 1.0 
    kn = nl/(nl-2)
    Ash3 = 0.2*kf*kn*P_max/(fy*Ach)
Ashy = max(Ash1,Ash2,Ash3)

#Resistencia a cortante

#Diagramas de flexocompresion mayorados
d_steel_may = {'fy' : 1.25*420*MPa, #Esfuerzo a la fluencia del acero
               'Es' : 200000*MPa, #Módulo de elasticidad del acero
               'eps_y' : 1.25*420*MPa/(200000*MPa)} #Deformación de fluencia del acero
theta = 0
flex_comp_data = col.flex_comp_data(d_conc, d_steel_may, 
                                    geom, steel, phi, theta)
Mn_x_may = flex_comp_data[2]
Pn_x_may = flex_comp_data[0]

theta = 90
flex_comp_data = col.flex_comp_data(d_conc, d_steel_may, 
                                    geom, steel, phi, theta)
Mn_y_may = flex_comp_data[3]
Pn_y_may = flex_comp_data[0]

#Diagrama en el eje x    
fig, ax = plt.subplots()
ax.plot(Mn_x_may/10**6, Pn_x_may/10**6)
ax.plot(-Mn_x_may/10**6, Pn_x_may/10**6)
ax.plot(Mn_x_may/10**6, Pn_x_may/10**6)
ax.plot(-Mn_x_may/10**6, Pn_x_may/10**6)
ax.scatter(cargas['M2']/10**6,cargas['P']*-1/10**6)
ax.set_xlabel("$M_x$ (MN-m)")
ax.set_ylabel("$Pn$ (MN)")
plt.show()

#Diagrama en el eje y  
fig, ax = plt.subplots()
ax.plot(Mn_y_may/10**6, Pn_y_may/10**6)
ax.plot(-Mn_y_may/10**6, Pn_y_may/10**6)
ax.plot(Mn_y_may/10**6, Pn_y_may/10**6)
ax.plot(-Mn_y_may/10**6, Pn_y_may/10**6)
ax.scatter(cargas['M3']/10**6,cargas['P']*-1/10**6)
ax.set_xlabel("$Mn_y$ (MN-m)")
ax.set_ylabel("$Pn$ (MN)")
plt.show()

#Momentos Probables
P_max = cargas['P'].min()
a1,i = col.find_a(b,Pn_x_may,P_max)
Mnx_des = Mn_x_may[i]
Pnx_des = Pn_x_may[i]

a2,i = col.find_a(h,Pn_y_may,P_max)
Mny_des = Mn_y_may[i]
Pny_des = Pn_y_may[i]

#Cortantes ultimas por capacidad
hn1 = 1.95*m
hn2 = 2.1*m
Vux = 2*Mnx_des/hn2
Vuy = 2*Mny_des/hn1

#Cortante que toma el concreto:
phi_c =0.75 #factor de reduccion
Y = abs(P_max)/(6*Ag)
Y = min(Y,0.05*fc)
Vcx1 = (0.17*lamb*(fc/MPa)**0.5*MPa+Y)*h*(b-r-d_st)
Vcx2 = (0.42*lamb*(fc/MPa)**0.5*MPa)*h*(b-r-d_st)
Vcx = min(Vcx1,Vcx2)
Vsx = (Vux-phi_c*Vcx)/phi_c

Vcy1 = (0.17*lamb*(fc/MPa)**0.5*MPa+Y)*b*(h-r-d_st)
Vcy2 = (0.42*lamb*(fc/MPa)**0.5*MPa)*b*(h-r-d_st)
Vcy = min(Vcy1,Vcy2)
Vsy = (Vuy-phi_c*Vcy)/phi_c

#Comprobacion de la sección transversal
Vumx = phi_c*(Vcx+0.66*(fc/MPa)**0.5*MPa*h*(b-r-d_st))
Vumy = phi_c*(Vcy+0.66*(fc/MPa)**0.5*MPa*b*(h-r-d_st))

if Vumx < Vux:
    print('Aumentar seccion')
else:
    print('OK')
    
if Vumy < Vuy:
    print('Aumentar seccion')
else:
    print('OK')

#Separación de estribos:
n = 2
n2 = 0
theta = math.radians(45)
Ast = A_4*n+A_3*n2*math.cos(theta)
sx = Ast*fy*(h-r-d_st)/Vsy

n1 = 2
n2 = 2
n3 = 0
theta = math.radians(45)
Ast = A_4*n1+A_3*n2+A_3*n3*math.cos(theta)
sy = Ast*fy*(b-r-d_st)/Vsx

d_p = steel['d_p']
s = min(sx,sy,6*d_p,15*cm)

#Diseño considerando rotulas en vigas
As = 4*A_5
a = As*1.25*fy/(0.85*fc*bv)
Mpx = As*1.25*fy*(dv-a/2)
Vux = 4*Mpx/(2*hn2)

bv2 = 35*cm
dv2=49*cm
As2 = 2*A_5+2*A_6
a = As*1.25*fy/(0.85*fc*bv2)
Mpy1 = As*1.25*fy*(dv2-a/2)
As3 = 3*A_5
a = As*1.25*fy/(0.85*fc*bv2)
Mpy2 = As*1.25*fy*(dv2-a/2)
Mpy = max(Mpy1,Mpy2)
Vuy = 2*Mpy/(2*hn2)


l1 = 4.21*m
l2 = 3.65*m

V2 = 2*Mpx/l1
V1 = 2*Mpx/l2

lc1 = 0.5*hn2+hv
Vcolx = 2*Mpx/lc1 + (V1+V2)*b/2/lc1

hv2 = 55*cm
lc2 = 0.5*hn1+hv2

l3 = 4.825*m
V3 = (Mpy1+Mpy2)/l3
Vcoly = Mpy/lc2+V3*h/2/lc2

#Fuerza cortante en el nudo
T1 = As*1.25*fy
T2 = T1
Vux = T1+T2-Vcolx

T3 = As2*1.25*fy
Vuy = T3-Vcoly

#revisando confinamiento de las vigas
if bv2 < 0.75*b:
    print('No confinado en x')
if bv < 0.75*h:
    print('No confinado en y')

phi_c = 0.85
befx = min(bv+b,bv)
Ajx = b*befx
phiVnx = phi_c*1.3*(fc/MPa)**0.5*MPa*Ajx
befy = min(bv2+h,bv2)
Ajy = h*befy
phiVny = phi_c*1*(fc/MPa)**0.5*MPa*Ajy
