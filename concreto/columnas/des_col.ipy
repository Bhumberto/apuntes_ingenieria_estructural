import numpy as np
import matplotlib.pyplot as plt
import math
import columnas_utils as col
import pandas as pd
%cd ..\..\etabs_oapi
import sismo_utils as sis
import etabs_utils as etb
%cd ..\concreto\columnas


# Definicion de las unidades
N = 1
m = 1
cm = 1/100
Pa = 1
MPa = 10**6
pulg = 2.54 / 100

# Definicion de varillas de acero:
d_3 = 3/8 * pulg
d_4 = 1/2 * pulg
d_5 = 5/8 * pulg
d_6 = 3/4 * pulg
d_8 = 1 * pulg

A_3 = d_3 ** 2 /4 * math.pi
A_4 = d_4 ** 2 /4 * math.pi
A_5 = d_5 ** 2 /4 * math.pi
A_6 = d_6 ** 2 /4 * math.pi
A_8 = d_8 ** 2 /4 * math.pi

#Definiendo geometría de la columna
b = 35*cm
h = 75*cm
r = 4*cm
column = col.Column(b, h, r)

# Concreto
fc = 21*MPa #Resistencia a la compresion
eps_u = 0.003 #Deformación unitaria ultima
column.set_concrete(fc, eps_u)

#Acero de refuerzo
fy = 420*MPa #Esfuerzo a la fluencia del acero
Es = 200000*MPa #Módulo de elasticidad del acero
eps_y = fy/Es #Deformación de fluencia del acero
column.set_steel_reb(fy, Es)

#Acero de refuerzo colocado
d_p = d_5 #diámetro principal
d_s = d_5 #diámetro secundario
d_st = d_3 #diámetro del estribo
n_f = 6  #filas de acero
n_c = 3 #columnas de acero
column.set_rebar(d_p, d_s, d_st, n_f, n_c)

#factor de minoración
phi = 0.65
column.compress_resist(phi)

#Datos diagrama a flexocompresion
column.biaxial_flex_comp()

#Importación de cargas
cargas = pd.read_csv('cargas.csv',sep=';')

#Conversion de unidades
cargas.P = cargas.P*9.81*10**3
cargas.M2 = cargas.M2*9.81*10**3
cargas.M3 = cargas.M3*9.81*10**3

#Diagrama a flexocompresión
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
column.plot_bi_f_c(ax,loads=cargas)
plt.title('Diagrama de Flexocompresión')
ax.set_xlabel("$\phi Mn_x$ (kN-m)")
ax.set_ylabel("$\phi Mn_x$ (kN-m)")
ax.set_zlabel("$\phi Pn$ (kN)")
plt.show()

#Eje x
fig, ax = plt.subplots()
column.plot_f_c(ax,loads=cargas,axis='x')
plt.show()

#Eje y
fig, ax = plt.subplots()
column.plot_f_c(ax,loads=cargas,axis='y')
plt.show()

#Comprobacion Viga Debil Columna Fuerte
#Datos de la viga
viga_1 = col.Beam(b=25*cm,h=40*cm,r=9*cm)
viga_1.set_rebar(d_s=d_5, n_s=4)

#Momento Resistente máximo con acero en tracción solamente
phi_f = 0.9
viga_1.calc_Mnv(phi_f)

#Menor carga que no se encuentra en el ultimo nivel
P_min = cargas[cargas.Piso!=6]['P'].max()*-1

#Filtro de datos para la menor carga
data = column.biaxial_f_c
data = data[data.theta==0]
data = data[abs(data.Pn-P_min)== min(abs(data.Pn-P_min))]

#Momento de diseño
Mnx_des = float(data.Mn_x)

#Verificación:
if 2*Mnx_des > 1.2*(2*viga_1.Mn):
    print('OK')
else:
    print('Viga más fuerte que la columna')
    
#Verificación por longitud de desarrollo en la columna
lu = 1.95
lamb = 1
psi_g = 1
psi_e = 1
psi_s1 = 1
psi_s2 = 0.8
psi_ts = 1.3
psi_ti = 1
db = 0.75 * pulg

#restricciones de la norma:
psi_ts_e = psi_ts*psi_e 
if psi_ts_e > 1.7:
    psi_ts_e = 1.7
    
sqrt_fc = (fc/10**6)**0.5*MPa
if sqrt_fc > 8.3*MPa:
   sqrt_fc = 8.3*MPa
    
ld3 = fy/(1.1*lamb*sqrt_fc)*psi_g*psi_e*psi_s2*psi_g*db

#Verificación
if 1.25*ld3 <= lu/2:
    print('Ok')
else:
    print('El acero no puede desarrolarse en la columna')

#Considerando el efecto de los estribos:
r = column.r
d_st = column.d_st
nb = column.n_c

cb1 = r+d_st+db*0.5
cb2 = (b-2*r-2*d_st-db)/(nb-1)/2
cb = min(cb1,cb2)

k_tr = 0

#restricciones de la norma
alpha = (cb+k_tr)/db
if alpha > 2.5:
    alpha = 2.5

#Por tanto:
ld3 = ld3/alpha 

#Verificación
if 1.25*ld3 <= lu/2:
    print('Ok')
else:
    print('El acero no puede desarrolarse en la columna')


#Longitud de confinamiento
hn = 2.1*m
h = column.h
Lo = max(b,h,hn/6,45*cm)

#Confinamiento de barras:
P_max = cargas.P.min()


#Área de refuerzo transaversal
s = 10*cm
bc = b-2*r
hc = h-2*r
Ach = bc*hc

#Revisión X
Ag = column.Ag
Ash1 = 0.09*s*bc*fc/fy
Ash2 = 0.3*s*bc*(Ag/Ach-1)*fc/fy
Ash3 = 0
nl = 10
if 0.3*fc*Ag < P_max:
    print('Es necesario confinar todas las barras longitudinales')
    kf = fc/175+0.6
    if kf < 1.0:
        kf = 1.0 
    kn = nl/(nl-2)
    Ash3 = 0.2*kf*kn*P_max/(fy*Ach)
Ashx = max(Ash1,Ash2,Ash3)

#Revisión Y
Ash1 = 0.09*s*hc*fc/fy
Ash2 = 0.3*s*hc*(Ag/Ach-1)*fc/fy
Ash3 = 0
nl = 10
if 0.3*fc*Ag < P_max:
    print('Es necesario confinar todas las barras longitudinales')
    kf = fc/175+0.6
    if kf < 1.0:
        kf = 1.0 
    kn = nl/(nl-2)
    Ash3 = 0.2*kf*kn*P_max/(fy*Ach)
Ashy = max(Ash1,Ash2,Ash3)

#Resistencia a cortante

#Diagramas a flexocompresión mayorados
#Momentos en X
flex_comp_data = column.nominal_PM(theta=0,mayored=True)
Pn_x_may = flex_comp_data[0]
Mn_x_may = flex_comp_data[2]

#Momentos en Y
flex_comp_data = column.nominal_PM(theta=90,mayored=True)
Pn_y_may = flex_comp_data[0]
Mn_y_may = flex_comp_data[4]

#Diagrama en el eje x    
fig, ax = plt.subplots()
column.plot_f_c(ax,loads=cargas,axis='x',factored=False)
ax.set_xlabel("$M_x$ (kN-m)")
ax.set_ylabel("$Pn$ (kN)")
plt.show()

#Diagrama en el eje y  
fig, ax = plt.subplots()
column.plot_f_c(ax,loads=cargas,axis='y',factored=False)
ax.set_xlabel("$Mn_y$ (kN-m)")
ax.set_ylabel("$Pn$ (kN)")
plt.show()

#Momentos Probables
P_max = cargas['P'].min()
i = column.find_i(Pn_x_may,P_max)
Mnx_des = Mn_x_may[i]
Pnx_des = Pn_x_may[i]

i = column.find_i(Pn_y_may,P_max)
Mny_des = Mn_y_may[i]
Pny_des = Pn_y_may[i]

#Cortantes ultimas por capacidad
hn1 = 1.95*m
hn2 = 2.1*m
Vux = 2*Mnx_des/hn2
Vuy = 2*Mny_des/hn1

#Cortante que toma el concreto:
phi_c =0.75 #factor de reduccion
Y = abs(P_max)/(6*Ag)
Y = min(Y,0.05*fc)
Vcx1 = (0.17*lamb*(fc/MPa)**0.5*MPa+Y)*h*(b-r-d_st)
Vcx2 = (0.42*lamb*(fc/MPa)**0.5*MPa)*h*(b-r-d_st)
Vcx = min(Vcx1,Vcx2)
Vsx = (Vux-phi_c*Vcx)/phi_c

Vcy1 = (0.17*lamb*(fc/MPa)**0.5*MPa+Y)*b*(h-r-d_st)
Vcy2 = (0.42*lamb*(fc/MPa)**0.5*MPa)*b*(h-r-d_st)
Vcy = min(Vcy1,Vcy2)
Vsy = (Vuy-phi_c*Vcy)/phi_c

#Comprobacion de la sección transversal
Vumx = phi_c*(Vcx+0.66*(fc/MPa)**0.5*MPa*h*(b-r-d_st))
Vumy = phi_c*(Vcy+0.66*(fc/MPa)**0.5*MPa*b*(h-r-d_st))

if Vumx < Vux:
    print('Aumentar seccion')
else:
    print('OK')
    
if Vumy < Vuy:
    print('Aumentar seccion')
else:
    print('OK')

#Separación de estribos:
n = 2
n2 = 0
theta = math.radians(45)
Ast = A_4*n+A_3*n2*math.cos(theta)
sx = Ast*fy*(h-r-d_st)/Vsy

n1 = 2
n2 = 2
n3 = 0
theta = math.radians(45)
Ast = A_4*n1+A_3*n2+A_3*n3*math.cos(theta)
sy = Ast*fy*(b-r-d_st)/Vsx

d_p = column.d_p
s = min(sx,sy,6*d_p,15*cm)

#Diseño considerando rotulas en vigas
#Viga en el sentido Y:
viga_1.ln = 5.65*m-0.2*m
#Vigas en el sentido X
viga_2 = col.Beam(b=35*cm,h=55*cm,r=9*cm)
viga_2.set_rebar(d_s=[d_5,d_6], n_s=[2,2])
viga_3 = col.Beam(b=35*cm,h=55*cm,r=9*cm)
viga_3.set_rebar(d_s=d_5, n_s=3)

viga_2.ln = 4.56*m-0.35*m
viga_3.ln = 4*m-0.35*m

#Momentos Probables en las vigas
#Sentido X
viga_1.a = viga_1.Ast*1.25*fy/(0.85*fc*viga_1.b)
Mpx = viga_1.Ast*1.25*fy*(viga_1.d-viga_1.a/2)
Vux = 4*Mpx/(2*hn2)
#Sentido Y
viga_2.a = viga_2.Ast*1.25*fy/(0.85*fc*viga_2.b)
Mpy1 = viga_2.Ast*1.25*fy*(viga_2.d-viga_2.a/2)
viga_3.a = viga_3.Ast*1.25*fy/(0.85*fc*viga_3.b)
Mpy2 = viga_3.Ast*1.25*fy*(viga_3.d-viga_3.a/2)
Mpy = max(Mpy1,Mpy2)
Vuy = 2*Mpy/(2*hn2)


l1 = 4.21*m
l2 = 3.65*m

V2 = 2*Mpx/l1
V1 = 2*Mpx/l2

lc1 = 0.5*hn2+viga_1.h
Vcolx = 2*Mpx/lc1 + (V1+V2)*b/2/lc1

hv2 = 55*cm
lc2 = 0.5*hn1+hv2

l3 = 4.825*m
V3 = (Mpy1+Mpy2)/l3
Vcoly = Mpy/lc2+V3*h/2/lc2

#Fuerza cortante en el nudo

#Sentido X (dos vigas llegando al nudo)
T1 = viga_1.Ast*fy
T2 = T1
Vux = T1+T2-Vcolx
Vux

#Sentido Y (una viga en el nudo)
T3 = viga_2.Ast*fy
Vuy = T3-Vcoly
Vuy

#En nudos viga columna de porticos a momento especiales usamos un factor de:
phi_c = 0.85
fact = {'IA':1.7,
       'IB':1.3,
       'IC':1.3,
       'ID':1.0,
       'IIA':1.3,
       'IIB':1.0,
       'IIC':1.0,
       'IID':0.7}

#Análisis en X:
tipox = 'I' #columna continua
v_c = 'y' #continuidad de la viga después del nudo
if v_c == 'y':
    if viga_2.b >= 0.75*h:
        tipox += 'A'
    else:
        tipox += 'B'
else:
    if viga_2.b >= 0.75*h:
        tipox += 'C'
    else:
        tipox += 'D'

#Análisis en Y:
tipoy = 'I' #columna continua
v_c = 'n' #continuidad de la viga después del nudo
if v_c == 'y':
    if viga_2.b >= 0.75*h:
        tipoy += 'A'
    else:
        tipoy += 'B'
else:
    if viga_2.b >= 0.75*h:
        tipoy += 'C'
    else:
        tipoy += 'D'

#Cortante que resiste el nudo direccion X
befx = min(viga_1.b+b,viga_1.b) #Ancho efectivo del nudo en X
Ajx = befx*b
phiVnx = phi_c*fact[tipox]*(fc/MPa)**0.5*MPa*Ajx
phiVnx

#Cortante que resiste el nudo direccion X
befy = min(viga_2.b+h,viga_2.b) #Ancho efectivo del nudo en X
Ajy = befy*h
phiVny = phi_c*fact[tipoy]*(fc/MPa)**0.5*MPa*Ajy
phiVny